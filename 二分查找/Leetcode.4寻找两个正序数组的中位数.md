### 原题链接 -- [[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)]

### 题目概述：
Tag : 「二分查找」

![image](https://user-images.githubusercontent.com/99656524/196598918-1621dfe4-dc49-4c80-ac4a-9ee2257301cf.png)

### 数据范围
* $nums1.length == m$
* $nums2.length == n$
* $0 <= m <= 1000$
* $0 <= n <= 1000$
* $1 <= m + n <= 2000$
* $-10^6 <= nums1[i], nums2[i] <= 10^6$

### 解法一：二分查找
这是一道二分查找困难题

刚看到题目我们不难想到，可以通过合并两个数组并排序后得出中位数，这是最容易想到的思路。如果用的是快速排序的方法，时间复杂度是 $O((m+n)log(n+m))$ 显然不符合题目要求的 $O(log(n+m))$ 复杂度

再进一步，我们可以使用归并排序的方法，用两个指针将两个有序数组合并成一个有序数组，这样的算法时间复杂度来到了 $O(m + n)$ 但也不满足题目要求的 $O(log(n+m))$

上面两个算法都没有真正意义上的利用数组有序的性质。对于一个有序的数组，我们可以用一种更快的方法来获得中位数，也就是二分查找

先来理解以下中位数的定义：

$$
将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。
$$

细想一下，二分查找就是利用了上述的定义将一个集合划分为两个部分，进而将每次的搜索范围缩小到原来的一半

怎么用二分查找解决这个问题呢？

一个数组的二分查找是根据“切一刀”的方法将一个数组的一分为二

两个数组也可以用“切一刀”的方法将两个数组一分为二。由于两个数组的长度是不一样的，所以第一个数组切的位置和第二个数组切的位置不一定是一样的，但是我们可以根据其中的一“刀”将另外的一刀算出来，假设在第一个数组切的位置为C1，则第二个数组切的位置为两个数组的总长度 / 2 - C2（C1+C2刚好分割一半的数组），这样我们只用对一个数组进行二分即可。并且我们对这切的一刀的左边和右边的数都是由要求的，如果要将一个集合一分为二，一个子集的元素永远大于另一个子集的全部元素。在一个有序数组的时候这个性质很容易就能体现出来，在 $mid$ 右边的数永远大于左边的数（数组的数都是单调递增的时候）,并且这两个集合的元素要相等。我们可以将上述的性质转换成一个恒成立问题，要使这一刀右边的数大于左边任意的数恒成立，就必有右边数组的最小值大于左边数组的最大值，即 $Lmax < Rmin$ ，若不满足条件，则需要继续二分调整切的位置。由于两个数组都是单调的，所以左边数组的最大值和右边数组的最小值就在这一刀的两边。需要注意的是，最值需要通过比较第一个数组和第二个数组获得，也就是 $Lmax = max(Lmax1,Lmax2)$ , $Rmin = min(Rmin1,Rmin2)$


由于 $Lmax <= Rmin$ ，并且两边元素相等，所以刚好将一个集合分成两个符合条件的部分，中位数即是两个最值的和 / 2

除此之外还有几种特殊情况

* C1 == 0：也就是第一个数组的左边部分没有数值，这个时候只能令其等于 $INTMIN$

* c1 == n: 也就是第一个数组的右边部分没有数值，这个时候只能令其等于 $INTMAX$

* C2 == 0: 也就是第二个数组的左边部分没有数值，这个时候只能令其等于 $INTMIN$

* C2 == m: 也就是第二个数组的右边部分没有数值，这个时候只能令其等于 $INTMAX$

C++代码：
```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        int m = nums2.size();
        if(n > m)return findMedianSortedArrays(nums2, nums1); //对数组元素个数小的进行二分，加快速度
        int l = 0,r = n;
        int Lmax = 0, Rmin = 0;
        while(l <= r)
        {
            int C1 = (l + r) / 2;  //C1 + C2 = (m + n + 1) / 2 <==> mid = (l + r + 1) / 2 （+1把取中间数的方式改成上取整）
            int C2 = (m + n + 1) / 2 - C1;

            int Lmax1 = (C1 == 0 ? INT_MIN : nums1[C1-1]);
            int Lmax2 = (C2 == 0 ? INT_MIN : nums2[C2-1]);
            int Rmin1 = (C1 == n ? INT_MAX : nums1[C1]);
            int Rmin2 = (C2 == m ? INT_MAX : nums2[C2]);
            //在同一个数组是必定小于的，因此要交叉对比
            if(Lmax1 <= Rmin2) 
            {
                Lmax = max(Lmax1, Lmax2);
                Rmin = min(Rmin1, Rmin2);
                l = C1 + 1;
            } 
            else r = C1 - 1; //第一个数组的最大值大于第二个数组的最小值，C1向左调整，C2向右调整
            
        }

        return (m + n) % 2 == 0 ? (Lmax + Rmin) / 2.0 : Lmax; //如果是偶数，则返回最值的平均值，如果是奇数就返回任意一个即可
    }
};
```

* 时间复杂度： $O(log(n+m)$
* 空间复杂度： $O(1)$
